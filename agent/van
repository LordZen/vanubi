#!/usr/bin/env python

# The little vanubi

import sys, socket, os, os.path, struct, stat, getpass, threading, signal

PORT = 62517
VERSION = "1"

################################
# list directory incrementally #
################################
import ctypes

DIR_p = ctypes.c_void_p
ino_t = ctypes.c_long
off_t = ctypes.c_long

class DIRENT(ctypes.Structure):
    _fields_ = [
        ('d_ino', ino_t),                 # inode number
        ('d_off', off_t),                 # offset to the next dirent
        ('d_reclen', ctypes.c_ushort),    # length of this record
        ('d_type', ctypes.c_ubyte),       # type of file; not supported
                                          #   by all file system types
        ('d_name', ctypes.c_char * 256),  # filename
	]
	
DIRENT_p = ctypes.POINTER(DIRENT)

C = ctypes.CDLL(None)

opendir = C.opendir
opendir.argtypes = [ctypes.c_char_p]

readdir = C.readdir
readdir.argtypes = [DIR_p]
readdir.restype = DIRENT_p

closedir = C.closedir
closedir.argtypes = [DIR_p]
closedir.restype = ctypes.c_int

# Utils

def thread (func):
	class Th (threading.Thread):
		def run (self):
			func ()
	th = Th()
	th.start()
	return th

def connect (is_main):
	s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
	s.connect(("localhost", PORT))

	s.send ("%s\n" % VERSION)
	
	if is_main:
		s.send ("main\n");
	
	s.send ("ident\n");
	s.send (getpass.getuser()+"@"+socket.gethostname()+"\n")
	return s

# Main connection, for opening and monitoring files
	
def main_conn ():
	s = connect (True)
	# send open request
	path = os.path.abspath (sys.argv[1])
	s.sendall ("open\n%s\n" % path)
	s.close ()

# Connection pool for user requests
	
def pool_conn ():
	s = connect (False)
	f = s.makefile ("r+b")
	s.close ()
	dirp = None
	while True:
		cmd = f.readline ()
		if not cmd:
			f.close ()
			return
		cmd = cmd.strip()
		if cmd == "read":
			process_read (f)
		elif cmd == "write":
			process_write (f)
		elif cmd == "exists":
			process_exists (f)
		elif cmd == "iterate_children":
			dirp = process_iterate_children (f)
		elif cmd == "next_children":
			dirp = process_next_children (f, dirp)
		elif cmd == "is_directory":
			process_is_directory (f)
		else:
			print "Unknown command", cmd
			return

# Automatically read and pass the path to the decorated function
def autopath (func):
	def _wrap (f, *args, **kw):
		path = f.readline ()
		if not path:
			f.close ()
			return
		path = os.path.abspath (path.strip())
		args = list(args)+[path]
		return func (f, *args, **kw)
	return _wrap

@autopath
def process_iterate_children (f, path):
	if not os.path.isdir (path):
		f.write ("error\n")
		f.write ("Not a directory: %s\n" % path)
		f.flush ()
		return

	dirp = opendir(path)
	if not dirp:
		f.write ("error\n")
		f.write ("Not a directory: %s\n" % path)
		f.flush ()
		return

	process_next_children (f, dirp)

def process_next_children (f, dirp):
	if not dirp:
		f.write ("error\n")
		f.write ("No opened directory\n")
		f.flush ()
		return

	# 50 files at once
	for x in range(50):
		dirent = readdir (dirp)
		if not dirent:
			f.write ("end\n")
			f.flush ()
			closedir (dirp)
			return
		else:
			f.write ("next\n")
			f.write ("%s\n", dirent[0].d_name)
			f.write ("%s\n", (dirent[0].d_type == 4) and "true" or "false")

	# wait for next() from the endpoint
	f.write ("wait\n") 
	f.flush ()
	return dirp
	
@autopath
def process_exists (f, path):
	if os.path.exists (path):
		f.write ("true\n")
	else:
		f.write ("false\n")
	f.flush ()

@autopath
def process_is_directory (f, path):
	if os.path.isdir (path):
		f.write ("true\n")
	else:
		f.write ("false\n")
	f.flush ()

@autopath
def process_read (f, path):
	try:
		size = os.path.getsize (path)
	except Exception, e:
		f.write ("error\n")
		f.write ("Cannot read file: %s\n" % e)
		f.flush ()
		return

	try:
		file = open (path, "rb")
	except Exception, e:
		f.write ("error\n")
		f.write ("Cannot open file for reading: %s\n" %e)
		f.flush ()

	f.write ("%d\n" % size)
	while size > 0:
		s = file.read (size)
		if not s:
			break
		size -= len(s)
		f.write (s)
	f.write ("0\n")
	f.flush ()
	file.close ()
	
@autopath
def process_write (f, path):
	try:
		# first try appending to see if we can write to the file
		tmp = open (path, "ab")
		tmp.close ()
	except Exception, e:
		f.write ("error\n")
		f.write ("Cannot open file for writing: %s\n" % e)
		f.flush ()
		return

	try:
		file = open (path+".tmp", "wb")
	except Exception, e:
		f.write ("error\n")
		f.write ("Cannot open temp file for writing: %s\n" % e)
		f.flush ()
		return
	
	f.write ("ok\n")
	f.flush ()
	
	while True:
		size = int(f.readline ())
		if not size:
			break
		while size > 0:
			s = f.read (size)
			if not s:
				break
			size -= len (s)
			file.write (s)
	file.close()
	os.rename (path+".tmp", path)

def main ():
	if len (sys.argv) < 2:
		print "Usage: %s FILE [FILE...]" % sys.argv[0]
		sys.exit(1)
		
	ths = [thread (main_conn)]
	for x in range(3):
		ths.append (thread (pool_conn))

if __name__ == "__main__":
	main ()
